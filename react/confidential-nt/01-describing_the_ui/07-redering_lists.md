## Rendering Lists

### 들어가면서

데이터 받았는데, 이 데이터를 이용해서 컴포넌트 여러 개 표시하고 싶을 때 있잖아. 그럴 때 사용할 수 있는게 자바스크립트 배열 메서드.

여기에서는 filter를 써서 데이터를 필터링하고 map을 사용하여 컴포넌트 배열을 리턴하는 것에 대해 공부할 것.

### 배열에서 데이터 렌더링하기

생략(map 사용법에 관한 기본적인 내용)

### 항목 배열 필터링하기

생략(filter 사용법에 관한 기본적인 내용)

### key로 목록의 항목 순서 유지하기

이런 식으로 map을 써서 컴포넌트를 리턴했을 때, 흔히 마주하는 오류가 있다.

> Warning: Each child in a list should have a unique “key” prop.

**각 배열 항목에는 해당 배열의 항목들 사이에서 고유하게 식별할 수 있는 문자열 또는 숫자인 key를 부여해야 한다.**

- 참고 : **map() 호출 내부의 JSX 요소에는 항상 key가 필요**

key가 중요한 이유? key는 **각 컴포넌트가 어떤 배열 항목에 해당하는지 React에 알려주어** 나중에 매칭할 수 있도록 함. 이는 배열 항목이 (정렬 등으로 인해) 이동하거나, 삽입되거나, 삭제될 수 있는 경우 중요해짐. 잘 만들어진 key는 **React가 정확히 무슨 일이 일어났는지 추론하고 DOM 트리를 올바르게 업데이트하는 데 도움**을 줌.

즉석에서 key를 생성하는 대신 데이터에 포함시켜야

- 참고 : 배열을 이용 + map을 사용하여 JSX를 렌더링하는데, 만약 li가 들어갈 수 없는 맥락이고, 돔 노드가 여러개라면 어떻게 해야할까? <></> 로는 key를 전달할 수 없음. div로 묶어줄수도 있으나 이게 싫으면 약간 더 길고 더 명시적인 \<Fragment> 구문을 사용.

  ```javascript
  const listItems = people.map((person) => (
    <Fragment key={person.id}>
      <h1>{person.name}</h1>
      <p>{person.bio}</p>
    </Fragment>
  ));
  ```

### key를 얻을 수 있는 곳

데이터 소스에 따라 서로 다른 key 소스를 제공

데이터베이스의 데이터: 고유한 데이터베이스 key/ID를 사용

로컬에서 생성된 데이터: 증분 카운터, crypto.randomUUID() 또는 uuid와 같은 패키지를 사용

### Key 규칙

1. **key는 형제간에 고유해야.** 다른 배열의 JSX 노드에는 동일한 key를 사용해도 괜찮
2. **key가 변경되지 않아야.** 그렇지 않으면 목적에 어긋나게 됨!(배열 항목 - 컴포넌트 매칭해보는 거..) 렌더링 중에는 생성하지 마라.(미리 생성해둬라 라는 뜻)

### React에 key가 필요한 이유는 무엇일까요?

파일에 이름이 없다고 상상해봐라. **특정 파일을 참조할 방법 중 하나는 파일에 순서를 부여하는 것.** 그러나 이 방법을 사용하게 되면, 파일 중 하나가 삭제되면 큰 혼란이 야기됨. 두번째 파일이 첫번째 파일이 되고..이런식으로.

파일 이름과 JSX key는 비슷한 역할을 함. **key를 사용하면 형제 항목 사이에서 특정 항목을 고유하게 식별할 수 있음.** key는 위치보다 더 많은 정보를 제공. **만약 재정렬로 인해 어떤 항목의 위치가 변경되더라도, 해당 항목이 사라지지 않는 한, React는 key를 통해 그 항목을 식별할 수 있음.**

- 참고 : 항목의 index를 key로 사용했을 때의 위험성에 대하여.. 사실 key를 지정하지 않으면, React는 인덱스를 key로 사용함. **그러나 특정 항목의 인덱스는 언제든 변경될 수 있음.** 새 항목이 삽입되거나, 삭제되거나, 배열의 순서가 바뀌는 등에 따라... 따라서 버그 가능성 커지겠지.

- 참고 : **key={Math.random()}과 같이 즉석에서 key를 생성하지 마라.** 이렇게 하면 **렌더링될 때마다 key가 일치하지 않아 매번 모든 컴포넌트와 DOM이 다시 생성됨.** (key가 고유하고 일관되게 유지될 경우, React는 이전 렌더링에서 사용된 DOM 요소를 재사용. key가 일치하고, 그 값이 렌더링 간에 안정적일 경우 React는 이미 있는 DOM을 재활용하고, 필요한 부분만 업데이트. 가상 돔의 특징. 변경 된 부분만 반영한다. 반면, key가 렌더링마다 변경되면 React는 이전 컴포넌트와의 관계를 인식하지 못하고 모든 항목을 새로운 컴포넌트로 간주하여 전체 리스트를 다시 렌더링.) 속도가 느려질 뿐만 아니라 **목록 항목 내부의 사용자 입력도 손실됨.** 대신 데이터에 기반한 안정적인 ID를 사용

- 참고 : 컴포넌트는 key를 prop으로 받지 않는다는 점에 유의. React 자체에서 힌트로만 사용됨. 컴포넌트에 ID가 필요한 경우 별도의 프로퍼티로 전달해야.
