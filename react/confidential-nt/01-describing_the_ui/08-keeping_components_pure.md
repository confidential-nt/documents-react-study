## Keeping Components Pure

### 들어가면서

일부 자바스크립트 함수는 순수함 -> 순수함수는 버그를 줄여주고 예측가능성을 높여줌.

하지만 이러한 이점을 얻으려면 몇가지 규칙을 준수해야.

### 순수성: 수식으로서의 컴포넌트

컴퓨터 과학(특히 함수형 프로그래밍..)에서 순수함수는 다음과 같은 특징을 가짐.

1. **자신의 일에만 신경쓴디.** 호출되기 전에 존재했던 객체나 변수를 변경하지 않는다. 즉, 외부 상태를 변경하지 않는다.
2. **동일 입력, 동일 출력.** 동일한 입력이 주어지면 항상 동일한 결과를 반환

순수 함수의 한 가지 예)

다음의 수학공식을 생각해보라.

y = 2x

- x = 2이면 y = 4. 항상
- x = 3이면 y = 6. 항상
- x = 3이면 **y 는 결코 시간이나 주식 시장 상태에 따라 9, –1, 2.5가 되지 않는다.** y는 항상 6이다.

이를 자바스크립트 함수로 만든다면?

```javascript
function double(number) {
  return 2 * number;
}
```

위 함수는 순수함수.

이 순수함수 예시를 통해 말하고 싶은 것은, React는 이 개념을 중심으로 설계되었다는 것. **즉, React는 우리가 작성하는 모든 컴포넌트가 순수 함수라고 가정한다.**

즉, **React 컴포넌트는 동일한 입력이 주어졌을 때 항상 동일한 JSX를 반환해야**

```javascript
function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>
        Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.
      </li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}
```

drinkers={2}를 Recipe에 전달하면 언제나 2 cups of water이 포함된 JSX를 반환

만약 drinkers={4}를 전달하면 항상 4 cups of water이 포함된 JSX를 반환

### 사이드 이펙트: 의도하지 (않은) 결과

**React의 렌더링 프로세스는 항상 순수해야.** 컴포넌트는 오직 JSX만을 반환해야 하며, **렌더링 전에 존재했던 객체나 변수를 변경해서는 안된다.**

규칙을 어기는 예시)

```javascript
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  // 나쁨: 기존 변수를 변경합니다!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

**위 컴포넌트는 이 컴포넌트는 호출할 때마다 다른 JSX를 생성하게 된다.**

게다가 다른 컴포넌트가 guest를 읽으면 렌더링된 시점에 따라 JSX도 다르게 생성됨.

예측 불가능해짐.

다시 y = 2x 공식으로 돌아가보면, 이제 x = 2라고 해도 y = 4라고 믿을 수 없어짐.

**테스트는 실패할 것이고, 사용자는 당황할 것이며, 비행기는 하늘에서 떨어질 수 있다**

위를 어떻게 좋은 코드로 고치느냐? guest를 prop으로 전달함으로써...이렇게 하면 컴포넌트는 순수해짐.

**일반적으로 컴포넌트가 특정 순서로 렌더링될 것이라고 기대해서는 안됨.** y = 2x를 y = 5x 앞에 호출하든 뒤에 호출하든 상관없음. 두 수식은 서로 독립적으로 해결됨. 컴포넌트도 마찬가지.

- 참고: StrictMode로 순수하지 않은 계산 감지하기 -> 컴포넌트가 렌더링되는 동안에는 기존 변수나 객체를 절대 변경해서는 안됨. **Strict Mode는 컴포넌트 함수를 두 번 호출함으로써 이러한 규칙을 위반하는 컴포넌트를 찾아내는 데 도움이 됨.** 순수 함수는 두 번 호출해도 아무 것도 바뀌지 않으며 결과가 일정. 순수하지 않은 함수는 두 번 호출하면 호출할 때 마다 변수의 값이 바뀌고 결과가 일정하지 못함. Strict Mode는 상용 환경에서는 아무런 영향을 미치지 않으므로 사용자의 앱 속도가 느려지지 않는다. 사용하는 것을 추천.

### 지역 변이: 컴포넌트의 작은 비밀

위의 예시에서는 컴포넌트가 렌더링하는 동안 기존 변수를 변경하는 것이 문제였음.

이를 좀 더 무섭게 들리게 하기 위해 “변이”라고 부르기도 함.

**순수 함수는 함수의 범위를 벗어난 변수나 호출 전에 생성된 객체를 변이하지 않는다.**

**하지만 렌더링하는 동안 ‘방금’ 생성한 변수와 객체를 변경하는 것은 완전히 괜찮다.**

예시)

이 예제에서는 [] 배열을 생성하고 이를 cups 변수에 할당한 다음 컵 12개를 그 안에 push함. 이것에 주목.

```javascript
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

cups 변수나 [] 배열이 TeaGathering 함수 외부에서 생성되었다면 이는 문제가 될 것 -> 기존 객체를 변경시키는 것이니까 변이.

**하지만 TeaGathering 내부에서 동일한 렌더링 중에 생성했기 때문**에 괜찮은거임.

**TeaGathering 외부의 어떤 코드도 이런 일이 일어났다는 것을 알 수 없음. 이를 “지역 변이”라고 한다.**

### 사이드 이펙트를 일으킬 수 있는 곳

함수형 프로그래밍은 순수성에 크게 의존하지만, **언젠가는 어딘가에서 무언가는 바뀌어야 함.** 화면 업데이트, 애니메이션 시작, 데이터 변경과 같은 이러한 변경을 사이드 이펙트라고 하며, **렌더링 중에 일어나는 것이 아니라 “부수적으로” 일어나는 일**

React에서 **사이드 이펙트는 보통 이벤트 핸들러에 속함.**

**이벤트 핸들러가 컴포넌트 내부에 정의되어 있긴 하지만 렌더링 중에는 실행되지 않는다. 따라서 이벤트 핸들러는 순수할 필요가 없다.**

다른 모든 옵션을 다 사용했는데도 **사이드 이펙트에 적합한 이벤트 핸들러를 찾을 수 없다? useEffect 사용.(useEffect 안에서 addEventListener 사용하는 거 말하는 것 같음)** 이렇게 하면 나중에 렌더링 후 사이드 이펙트가 허용될 때 React가 이를 실행하도록 지시.

**하지만 이 방법은 최후의 수단으로 사용해야함.**

가능하면 렌더링만으로 로직을 표현하고자 노력해봐라. 많은 것들을 얻을 것이다.

- 참고 : 왜 React는 순수성을 중요시할까요? 정리하자면 유용성 + 성능상의 이점.

  1. 컴포넌트를 다른 환경(예: 서버)에서 실행할 수 있다. 동일한 입력에 대해 동일한 결과를 반환하기 때문에 하나의 컴포넌트가 많은 사용자 요청을 처리할 수 있음. => 순수성은 서버 사이드 렌더링(SSR)이나 정적 사이트 생성(SSG) 같은 기술에서 특히 중요. 순수 컴포넌트는 동일한 입력(props와 state)에 대해 항상 동일한 출력(렌더링된 결과)을 반환. 이 특성 덕분에 서버 환경에서 컴포넌트를 실행해도 클라이언트 사이드에서 실행했을 때와 동일한 결과를 얻을 수 있음. 하나의 컴포넌트가 많은 사용자의 요청을 처리할 수 있는 이유는, 순수성 덕분에 동일한 요청에 대해서는 항상 동일한 결과를 빠르게 생성할 수 있기 때문. 왜냐? 순수 컴포넌트는 주어진 props와 state에 대해 예측 가능한 결과를 반환하며, 이는 불필요한 렌더링을 방지하고 성능을 최적화하는 데 기여하기 때문. => 불필요한 렌더링을 방지한다는 것은 바뀐 부분만 렌더링하기 때문
  2. 입력이 변경되지 않은 컴포넌트는 렌더링 건너뛰기(memo)를 통해 성능을 향상시킬 수 있음. 순수 함수는 항상 동일한 결과를 반환하므로 캐싱해도 안전
  3. 깊은 컴포넌트 트리를 렌더링하는 도중에 일부 데이터가 변경되면 React는 오래된 렌더링을 완료하기 위해 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있음. 순수성 덕분에 언제든지 계산을 중단해도 안전. => 동일 입력에 대하여 동일 결과를 보장하므로..
     - 참고: React는 렌더링 작업을 효율적으로 관리하기 위해 "Fiber"라는 새로운 알고리즘을 도입. Fiber는 React가 렌더링 작업을 중단하고 필요에 따라 다시 시작할 수 있게 해주는 기능을 포함. 이는 특히 깊은 컴포넌트 트리를 렌더링할 때 유용. 컴포넌트가 순수할 때, React는 이미 진행 중인 렌더링 작업을 중단하고 더 우선순위가 높은 업데이트가 있을 경우 이를 처리한 후 다시 원래 작업으로 돌아갈 수 있음. 순수성이 보장되므로, 중단된 작업을 다시 시작할 때 동일한 입력에 대해 동일한 출력이 보장됨. 이는 React가 사용자 인터랙션 같은 중요 작업에 빠르게 반응하고, 나중에 덜 중요한 작업을 완료할 수 있게 한다.
  4. 모든 새로운 React 기능은 순수성의 이점을 활용. 컴포넌트를 순수하게 유지하면 React 패러다임의 힘을 발휘할 수 있음.
