# JavaScript의 모듈 시스템과 번들러 알아보기

![image](https://wormwlrm.github.io/static/cb7ba2cf5d7da0c4d913802263ed08b0/3c492/history.png)

## JavaScript와 모듈 시스템

최초의 JavaScript는 HTML에서 JavaScript 원본 소스를 제공해 브라우저에서 순서대로 로드하는, 아주 간단한 모듈 시스템만을 제공했다. 웹에서 대형 어플리케이션이 만들어질 것이라고 생각하지 않았기 때문에 Module이 없었고, 파일을 여러 개로 만들어 개발할 수 없었다.

스크립트를 로드하는 방식은 전역 컨텍스트에서 모듈 간 충돌이 발생한다는 문제가 있었다.
모듈 간 스코프가 구분되지 않아 다른 파일을 오염시키는 경우가 그랬다.

```
<html>
  <script src="/src/foo.js"></script>
  <script src="/src/bar.js"></script>
  <script src="/src/baz.js"></script>
  <script src="/src/qux.js"></script>
  <script src="/src/quux.js"></script>
</html>
```

foo.js에서 선언한 변수 A가 bar.js에도 선언이 되어 있으면 재정의 되는 상황이 그 예시다.
이를 피하기 위해 개발자들은 모듈 로드 순서를 지정하는데 불필요하게 많은 시간을 쏟곤 했다.

2008년 브라우저 외부에서도 JS를 사용할 수 있는 Google의 V8엔진이 공개되며 서버 사이드에서도 JS를 활용하자는 움직임이 생겼다.
이후 모듈화에 대한 필요성이 대두되면서 CommonJS 모듈 방식이 탄생하게 되었다. (당시 JS에는 import 같은 표준 모듈 문법이 없었다.)

### CommonJS

- JS를 브라우저와 서버 사이드 애플리케이션, 데스크톱 애플리케이션 등 범용적인 용도로 사용하기 위한 모듈 시스템
- require 함수와 module.export를 사용하는 방식

트리쉐이킹이 어렵고 순환 참조에 취약하다는 등 단점이 명확했지만 초창기 JS 발전을 위해 모듈 시스템은 반드시 필요했다.
(파일을 여러 개로 나눠 개발할 수 없다면 큰 규모의 프로그램을 만들기 어렵기 때문) 따라서 JS의 런타임 Node.js는 CommonJS를 채택했다.

```
// CommonJS

// 모듈 정의
module.exports = foo;

// 모듈 사용
const foo = require('./foo');
```

범용적인 JS를 위한 모듈 시스템이기에 모든 의존성이 로컬 디스크에 존재해 필요한 모듈을 바로 사용하는 환경을 전제한다.
따라서 동기적으로 모듈을 호출하는 방식을 선택했는데, 이 때문에 **비동기 로드는 고려하지 않아 브라우저에서는 CommonJS를 사용할 수 없었다.** 브라우저에서는 JS 파일을 저장하지 못해 매번 불러와야 하기 때문에 언제나 로딩과 비동기를 고려해야 하는데, 비동기 로드가 고려되지 않는다면 어떤 것이 먼저 로딩되고 실행될지 모르기 때문이다.

이후 CommonJS 모듈 시스템을 브라우저에서도 활용하기 위한 최초의 빌드 도구 Browserify도 탄생하게 된다.

### AMD(Asynchronous Module Definition)

- 비동기 상황에서도 JS 모듈을 쓰기 위해 CommonJS와 협의하다 독립한 별도의 시스템
- 복잡한 문법이지만 비동기적으로 모듈을 호출해 CommonJS보다 성능이 우수하며 브라우저/서버 사이드 모두 호환 가능

```
// AMD

// 모듈 정의
define([
  'jquery',
  'underscore',
  // 의존 모듈들을 배열로 나열
], function ($, _) {
  // 의존 모듈들은 순서대로 매개변수에 담김

  return {
    // 외부에 노출할 함수들만 반환
  };
});

// 모듈 사용
require([
  ...
  // 사용할 모듈 배열로 나열
], function (...) {
  // 사용할 모듈들이 순서대로 매개변수에 담김
});
```

### UMA(Universal Module Definition)

- CommonJS와 AMD 방식을 모두 호환하도록 조건문으로 분기, 팩토리 패턴으로 구현

```
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD 방식
    define(['jquery', 'underscore'], factory);
  } else if (typeof exports === 'object') {
    // CommonJS 방식
    module.exports = factory(require('jquery'), require('underscore'));
  } else {
    root.foo = factory(root.$, root._);
  }
})(this, function ($, _) {
  // 모듈 정의
  var foo = {
    // ...
  };

  return foo;
});
```

### ES6 표준 모듈 시스템(ES Module)

- UMD는 CommonJS와 AMD의 호환성만 해결할 뿐 모듈 시스템의 부재라는 근본적인 문제는 해결하지 못했다.
- JS 언어 자체에서 모듈 시스템을 지원해야 한다는 필요성이 높아지면서 2015년 JS 표준 모듈 시스템이 명세되었다!

- 비동기/동기 지원
- 간결한 문법과 실제 객체/함수를 바인딩해 편리한 순환 참조 관리
- 정적 분석(코드를 실행하지 않아도 분석 가능)이 가능해 트리 쉐이킹도 용이함

```
// ES6
import foo from 'bar';

export default qux;
```

### 트랜스 파일러(Transpiler)

- ES6에서 표준 모듈 문법이 정의되었음에도 구형 브라우저에서는 적용하지 못하는 문제점이 있었다.
- 한 번 컴파일하면 구형 브라우저에서도 동작하는 JS 코드가 나오게 하는 도구로, 바벨(Babel)이 가장 유명하다.
- 개발 할 때는 최신 JS 문법을 쓰되 바벨로 컴파일하면 같은 동작임에도 구형 브라우저에서 호환이 되는 JS 코드로 변환이 되기에 개발자들은 호환성 걱정 없이 최신 문법을 사용할 수 있게 되었다.

CoffeeScript, TypeScript 같은 JS의 슈퍼셋 언어의 등장 역시 하나의 방법이다.

### 태스크 러너(Task Runner)

- CommonJS, AMD, UMD 방식으로 모듈 시스템을 다룬 이유는 *스코프가 구분되는 모듈을 만들기 위함*이다.
- 왜? 여러 모듈을 조합해 중복 코드를 줄이면서 생산성, 퍼포먼스가 높은 프로그램을 개발하기 위함이었다.
- 이를 위해서는 코드 작성, 컨벤션 유지를 위한 린트 사용, 전처리가 필요한 언어 컴파일, 소스 코드 축소 및 번들과 같은 과정이 필요했다.
- 태스크 러너는 프로덕트 개발 과정에서 이런 과정(린팅, 빌딩, 테스팅 등)을 자동화하는 도구다. (ex. Grunt, Gulp)
- Node.js와 웹 생태계의 성장으로 프론트엔드 분야의 과업이 늘어나면서 번들을 전문적으로 도와주는 *모듈 번들러*가 등장하게 된다.

## JavaScript와 모듈 번들러

모듈 번들러란 JS 모듈을 브라우저에서 실행할 수 있는 단일 JS 파일로 번들링하는 프론트엔드 개발 도구를 말한다.
아직 모든 브라우저가 모듈 시스템을 완전히 지원하지 않고, 코드의 종속성 관리에 도움이 되며, 여러 에셋을 로드하는데 도움이 된다.

이후 단순히 '번들'을 넘어 개발, 빌드, 최적화를 위한 플러그인을 제공하면서 태스크 러너나 최적화 도구를 사용하지 않게 된다.
이러한 변화를 야기한 모듈 번들러로는 웹팩(Webpack), 롤업(Rollup), 파셀(Parcel)이 있다.

### 웹팩(Webpack)

1. 오래된 만큼 생태계가 풍부하고 안정성이 높다. => 서브파티 라이브러리 관리나 전처리, 에셋 관리 등 강점이 있다.
2. 웹 애플리케이션에서 사용하는 에셋들을 JS로 변환하고 이를 분석해 번들한다. => 구성이 타 번들러에 비해 복잡하고 설정할 게 많다.
3. 웹팩이 제공하는 개발 서버도 훌륭한 편 => 개발 시 변경사항을 자동으로 교체하는 라이브 리로딩 + HMR
4. 트리 쉐이킹이 지원되지만 CommonJS -> ES6로 교체해야 하고, 별도 플러그인 설정이 필요하며 복잡한 문서, ES6 모듈 형태로 빌드할 수 없다는 등 일부 단점이 있다.

### 롤업(Rollup)

1. 웹팩과 유사하나 ES6 모듈 형식으로 빌드 결과물을 출력할 수 있다. (웹팩/파셀이 자체 로더가 있는 반면 롤업은 ES6 모듈이 디폴트)
2. 코드 스플리팅에서 강점 => 중복 제거에 특화되어 있음. 진입점이 다르기 때문에 중복되는 부분을 알아내는데 용이함
3. 단, 해시 캐스캐이딩(하나의 파일의 해시가 바뀌면 그것을 참조한 파일의 해시도 알아서 바뀜)이 약하다는 단점이 있다.

### 파셀(Parcel)

1. 별도의 설정 없이 동작한다. => 설치만 하면 별도의 설정 없이 빌드 명령어로 바로 사용 가능. 웹팩과 달리 JS 진입점을 지정하는 게 아니라 애플리케이션 진입을 위한 HTML 파일 자체를 로드하기 때문임. 따라서 HTML 파일을 순서대로 읽으며 에셋들을 직접 참조함. (웹팩은 읽기 위해 JS로 변환해야 하고 이를 위해 또 뭔가를 깔아야 함)
2. 트리 쉐이킹에도 강점 => ES6 / CommonJS 모듈 모두 지원함
3. 트랜스 파일러도 간편하게 설정할 수 있음 => 번들러는 JS만 읽기에 CSS나 다른 에셋들을 번들에 추가하려면 트랜스 파일러를 사용해야 함. 웹팩과 롤업은 트랜스 파일러에 파일 유형을 일일이 설정해야 하지만 파셀은 .babelrc, .postcssrc, .posthtml 같은 설정 파일을 프로젝트 루트 디렉토리에 만들기만 하면 알아서 세팅을 해준다.
4. 단 아직 안정적이지 않은 듯 보이며 생태계가 좁다.


---


참고


https://velog.io/@teo/vite#%ED%94%84%EB%A1%A4%EB%A1%9C%EA%B7%B8


https://wormwlrm.github.io/2020/08/12/History-of-JavaScript-Modules-and-Bundlers.html#%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C


https://velog.io/@sik02/Vite%EB%9E%80#%EF%B8%8F-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0
