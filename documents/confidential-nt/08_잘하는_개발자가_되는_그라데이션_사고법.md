[원문](https://velog.io/@teo/gradation-thinking)

# 잘하는 개발자가 되는 그라데이션 사고법 (추상화 계층과 데이터 흐름 이해하기)

## 들어가면서

잘하는 개발자가 되려면 알아야하는 개념: 추상화 계층, 데이터 흐름

어떻게하면 요구사항을 코드로 잘 만들어낼 수 있을까?

"계층을 분리하고 연결하여 생각하기"

## 프롤로그

글쓴이가 예전에 작성한 '데이터 관점으로 바라보기'라는 글을 복습하는 내용.

테트리스 구현하기 -> 개발 문법도 알고, 테트리스 규칙도 아는데, 막상 구현해보려면?

어렵다.

왜? 컴퓨적으로 사고하는 법을 전혀 몰랐었기 때문. 즉, **데이터의 관점으로 바라보는 방법을 제대로 몰랐기 때문에.**

숫자 야구와 같이 단순한 프로그램은 그래도 어떻게든 피지컬로 밀어붙히면 되는데, 조금만 더 문제가 복잡해지면 구현하는 것이 힘들어짐.

그냥 무지성으로 구현하려고 하지말고 테트리스를 데이터의 관점으로 바라본다면? 구현이 쉬워진다.

- 테트리스의 세상을 이차원 배열로 바라보는 데이터의 관점으로 생각하고 표현
- 테트리스의 세상이 이차원 배열이 되면 테트리스 블록을 블록이 아니라 데이터 0과 1이 조합된 배열로 데이터로 취급할 수 있음.
- 블록의 회전은 이미지를 90도로 조작하는게 아니라 미리 회전된 데이터들의 배열의 집합으로 취급 할 수 있게 됨.
- 한줄을 제거하기 위해 다 차있는지는 같은 열의 모든 값들이 0보다 크다면 과 같은 식으로 표현을 할 수 있게 됨.

![](https://velog.velcdn.com/images/teo/post/d709bd5f-76e9-4c92-90f4-00d5cd0c0ea2/image.png)

이렇게 **요구사항을 데이터의 관점으로 볼 수 있게 되면, 요구사항을 실제로 구현할 수 있게 됨.**

이것은 반드시 의식적으로 연습하고 훈련해야 깨달아지는 영역.

하지만 이렇게 데이터의 관점에 눈을 뜨고 구현이 쉬워지더라도 여전히 어려운 것들이 남아있음.

블록과 회전과 바닥을 닿거나 1줄이 맞춰지는 것과 같은 것들을 데이터로 쉽게 표현을 하고 구현을 했지만 프로그램은 이 모든 것들이 하나로 온전히 조립이 되어 제 기능을 했을 때 비로소 제대로 구현한 것이 됨.

그래서 그 다음 개발의 레벨은 **이러한 각각의 구현을 어떻게 잘 조립하는가?** 에 있음.

이 조립은 생각보다 쉽지 않음. 우리가 만들어낸 수많은 스파게티 코드를 생각해보라.

일단 **구현은 계속 하고 있지만 이 코드가 여기에 있어야 하는지 저기에 있어야 하는지 어떤 위치에서 어떻게 조립을 해야하는지에 머리가 복잡해지는 상태가 됨.**

어떻게 하면 잘 조립할 수 있을까? 이를 위해 먼저 추상화 계층과 데이터흐름이라는 개념을 알고 있어야한다.

## 추상화

추상화가 뭔지 이해하기 위해 그 반대의 개념부터 먼저 살펴보자.

추상화의 반대는? 구현. 아래의 이미지를 보라.

![](https://velog.velcdn.com/images/teo/post/383d4805-26be-4e2e-a719-3d691e913f81/image.png)

구현된 코드를 통해 저기 빈칸에 이름을 넣는 것. 이것이 추상화다.

(더 정확하게는 구현된 내용을 함수 등으로 빼서 이름을 붙인다음, 복잡한 세부사항은 숨김으로써 사람이 더 이해하기 쉽게 하는 것. 단순화 시키는 것.)

일단 우선은 추상화에 대한 기본적인 접근을 내가 구현한 코드에 적절한 이름을 붙여주는 것이라고 생각하자. 구현된 코드에 이름을 붙여주게 되면 **복잡한 코드 구현부분을 감추고 조금 더 사람이 이해하기 쉬운 이름으로 부를 수 있게 됨**

구현은 요구사항을 데이터의 관점으로 기술하는 것이라면 데이터의 관점에서 기술된 것을 보다 사람의 언어에 가까운 코드로 표현 하는 것이 추상화.

그래서 추상화는 복잡한 구현부분을 감추면서,

1. 보다 명세에 가까운
2. 행동을 기술하는
3. 선언적인
4. 사람의 개념에 가까운 코드를 작성할 수 있게 됨.

-> 더 가독성이 좋아짐, 유지보수하기 좋은 코드가 됨, 추상화는 코드를 간소화하므로 시스템의 복잡성을 관리 가능한 수준으로 줄이는 데 도움, 특히 협업할 때 팀의 생산성 높임

또 추상화가 중요한 이유: 추상화된 코드는 잘 변하지 않는다 라는 점. **구현의 세부내용은 바뀔 수 있지만 추상화된 코드는 곧 명세이자, 사용자의 요구사항에 가까운 코드이며 요구사항이 변하기 전까지는 그 이름과 코드는 거의 유지가 된다는 의미**

그리고 이렇게 잘 변하지 않는 코드들로 조립을 해야만 조립이 틀어지거나 구현이 복잡해져서 코드가 같이 복잡해져도 조립을 담당하고 있는 코드들은 유지가 됨. 이러한 것을 인터페이스(Interface)라고 함.

이렇게 추상화된 코드가 쌓이게 되면 잘 변하지 않는 경계(인터페이스)가 생기면서 추상화 계층(Abstraction Layer)이 만들어지게 됨.

이렇게 추상화 계층이 만들어지고 나면 **우리는 계층과 계층간의 조립으로 프로그래밍을 할 수가 있고 이러한 추상화 계층은 기존과는 다른 새로운 세상과 관점으로 프로그래밍을 할 수 있도록 만들어줌**

## 추상화 계층(layer)

추상화는 복잡하고 저수준의 컴퓨터에 가까운 코드들을 인간에 가까운 개념으로 다시 정의해서 만들 수 있있다는 점에서 중요.추상화 계층은 새로운 세계와 관점을 만든다.

또한 그리고 이러한 계층이 한번 만들어지고 나면 우리는 **그 이하의 수준에서 생각을 하지 않고 고수준의 사고로 프로그래밍을 할 수 있게됨.** 그 이면의 세계를 몰라도 우리는 더 새로운 것을 만들어낼 수 있음.

프론트엔드의 관점에서 한번 생각을 해본다면 화면을 만들 때 실제로 화면의 데이터는 2차원 배열의 픽셀값으로 되어 있지만 실제 프론트엔드 개발자는 아무도 픽셀의 배열 데이터를 상상하면서 개발하지는 않음. 우리는 HTML과 CSS를 통해서 화면을 생각하고 만들고 있으며, React와 같은 프레임워크를 기반으로 새로운 계층 위에서 사고를 할 수 있게 됨.

좋은 추상화계층은 코드를 더 적게 쓰면서도 더 많은 행위를 더 나은 고수준의 사고로 개발을 할 수 있게 만들어 줌.

## 좋은 추상화 코드를 작성하는 법

```javascript
const currentDate = new Date();
const firstDate = new Date(
  currentDate.getFullYear(),
  currentDate.getMonth(),
  1
);
const firstDay = firstDate.getDay();
firstDate.setDate(firstDate.getDate() - firstDay);
```

위와 같은 코드가 있다.

(코드에 대한 설명)
![](https://velog.velcdn.com/images/teo/post/6f7b0aff-f452-494a-a6f0-3b673af0979f/image.png)

코드 이해 다소 어려움. 이러한 코드에 적당히 이름을 지어준다면 이제 훨씬 더 복잡한 구현이 숨겨지고 간결해지고 가독성이 좋아지는 코드가 될 수 있음. 다음과 같이.

![](https://velog.velcdn.com/images/teo/post/900bc4e7-e4a5-4e5f-91ee-0fdf8d3edb12/image.png)

**그렇다면 무조건 복잡해보이는 코드를 이름을 붙여 단순화하기만 하면 좋은 추상화일까?**

### 추상화의 함정 - 추상화는 구현을 숨긴다!

추상화는 구현을 숨기기 때문에 코드의 맥락을 모르는 사람은 함축된 이름만 가지고 이게 어떤 구현인지 예측을 해야

맥락을 알고 만든 사람은 이 맥락을 정확하게 이해하지만 맥락을 모르는 사람은 이름만 가지고 복잡한 구현내용을 추측을 해야

따라서 함축된 이름을 가지고도 복잡한 구현이 예측이 가능하도록 딱 맞는 좋은 이름을 짓는 것이 추상화의 가장 큰 중요한 핵심

쉽지 않은 이유: **함축적이고 간결한 이름**을 지으면서도 복잡한 구현을 감춰야 되기 때문에 **예측이 가능하고 설명적인 이름을 지어야** 되면서도 **복잡한 구현에 딱 맞는 직관적인 단순한 이름**을 발견하기가 어렵고, **이름은 한 번만 짓는 게 아니라 계속 지어야 되기 때문에 일관성을 지녀야**하기 때문에...

그래서 이름 지을 때 이러한 것들을 의식하면서 이게 좋은 이름인지 고민해봐야 함. -> 개발을 잘하게 만들어주는 핵심 포인트.

### 좋은 추상화는 이름뿐만 아니라 수준(Level)도 중요!

추상화에서 좋은 이름보다 더 중요한 것은 추상화의 수준(Level)

추상화를 하게 되면 복잡한 구현 부분이 숨겨지고 그 구현을 설명하는 함축적인 이름이 된다고 함. 반대로 말하면 **그 함축적인 이름에서 복잡한 구현 부분을 예측해야 하는 문제가 발생을 하게됨.**
어떻게 하면 더 **예측가능하게** 표현을 할 수 있을까?

추상화는 한번에 다 이뤄질 필요가 없음. **추상화의 과정을 한번에 가는 것이라 아니라 여러번에 걸쳐 조립을 해서 사용할 수 있도록 적절한 수준으로 나눠줄 필요가 있음.** -> 좀 더 맥락적인 정보를 가져갈 수 있도록, 그냥 무지성으로 하나의 코드 덩어리를 하나의 함수로 만들어버리는 것이 아니라, 조립할 수 있는 구조로 추상화 해보자는 것.

추상화에는 다양한 방식이 존재. 데이터를 추상화 할 수가 있고, 프로세스를 추상화 할 수 있음.

추상화는 결국 이름을 붙이는 것이라고 생각하면 데이터의 추상화는 변수명을 짓는 것이고 프로세스의 추상화는 함수명을 짓는 행위라고 생각해도 좋음.

![](https://velog.velcdn.com/images/teo/post/91876f60-45b2-45a7-8d66-f8650fe330b3/image.png)

우리가 만들었던 코드에 이미 붙여진 변수명들(데이터 추상화)과 이러한 이름들이 변화하는 과정에 이름을 붙이는 것(프로세스 추상화)라는 관점에서 코드를 살펴보면 그 사이에서 적절한 수준을 발견해 볼 수 있음.

데이터 추상화: currentDate, firstDate, firstDay
프로세스 추상화: currentDate -> firstDate(currentDate 에서 firstDate 로 변하게 하는 프로세스) / firstDate -> firstDay

좋은 추상화의 수준과 좋은 이름을 함께 고민한 결과:
![](https://velog.velcdn.com/images/teo/post/9ca21c5a-84d1-4514-be55-311bab3a58ad/image.png)
-> 단순하고, 외우기도 쉽고, 재사용도 가능하고 모듈화도 가능한 멋진 코드가 됨.

코드를 작성을 할 때, **데이터의 이름과 데이터의 이름이 어떻게 변하는지에 대한 이 과정을 적절히 추상화를 하면서 여기에 정말 좋은 이름을 붙여보면** 재사용도 가능하고 모듈화도 가능하면서 가능한 수준의 추상화 계층을 만들어낼 수 있을 거라고 생각.

좋은 추상화된 코드의 특징을 제시 -> 내 코드가 이런지 검토할 때 사용하자.

1.  안정성:
    좋은 코드는 안정적이고 변하지 않는 특성을 갖습니다. 이는 코드의 예측 가능성과 유지 보수성을 높여줍니다.

2.  단순성:
    좋은 코드는 단순합니다. 단순한 코드는 이해하고 사용하기 쉽게 만들어주며, 버그 발생 가능성을 낮춥니다.

3.  목적에 적합한 수준:
    좋은 코드는 적절한 추상화 수준을 가집니다. 너무 추상화되면 특수한 경우에만 쓰이는 코드가 됩니다. 덜 추상화되면 여전히 복잡한 코드가 됩니다.

4.  재사용 가능성:
    좋은 코드는 재사용 가능해야 합니다. 유사한 도메인이나 기능에서 쉽게 확장하고 적용할 수 있습니다.

5.  가독성:
    좋은 코드는 가독성이 높습니다. 함축된 이름으로도 코드의 목적과 의도를 쉽게 이해할 수 있도록 합니다.

6.  일관성:
    좋은 코드는 일관성을 유지합니다. 그래서 숨겨진 구현에 대해 예측할 수 있습니다.

        (무엇보다 좋은 추상화 계층은 새로운 세계와 관점을 제공한다.)

그리고 추상화는 한번에 만들어지지 않는다. 추상화는 점진적으로 만들어 질 수 있다는 것을 기억해야. 너무 미세한 추상화는 의미가 없고 너무 많은 추상화 또한 의미를 가지기 힘드므로 적절한 계층을 나눠서 조립한다는 관점을 가지고 있어야

![](https://velog.velcdn.com/images/teo/post/cbe029a8-a4d0-4fb1-917d-4684c8799680/image.png)

## 추상화 이야기 정리.

추상화에서 중요한 것: 좋은 이름 부여와 적절한 추상화 수준 설정

좋은 이름은 코드의 의도와 기능을 명확하게 전달하고, 적절한 추상화 수준은 복잡성을 효과적으로 관리하며 필요한 정보만을 제공

그리고 이렇게 추상화된 계층을 만들게 되면 자연스럽게 계층간의 데이터 흐름이 생겨나게 됨.

## 데이터 흐름(Data Flow)

추상화는 수준이 존재한다고 했음. 소프트웨어를 구성하는 계층을 극단적으로 추상화를 하면 아래와 같이 그림을 그려볼 수 있음.
이것을 다른말로 우리는 아키텍쳐라고 함.

일반적으로 - 특히 프론트 엔드에서 - 사용하고 있는 아키텍처는 다음과 같이 생김.

![](https://velog.velcdn.com/images/teo/post/bc0267fb-01e2-42ad-9566-977d2dd3cc48/image.png)

소프트웨어의 데이터 흐름 사이클: 사용자와 컴퓨터간의 소통 과정이 인테페이스를 통해 전달되고 비지니스 로직을 통해 데이터 변경을 요청하며 데이터 접근자가 실제 데이터를 변경. 변경된 데이터는 다른 데이터 접근자를 통해서 새로운 데이터의 형식으로 변경이 되며 비지니스로직으로 인해 화면이나 음성등의 인터페이스가 되어 사용자에게 전달이 되게됨.

이러한 아키텍처를 프론트엔드에서 주로 사용하는 용어로 표현해서 조금 더 익숙한 형태로 만들어 본다면 아래와 같이 표현할 수 있음.

![](https://velog.velcdn.com/images/teo/post/729edfbe-2285-4bb8-a5af-7d15fd0f2650/image.png)

각 계층에 맞는 영역이나 관련 라이브러리들이 자연스럽게 떠오를 것.

이러한 데이터 흐름은 **사용자를 중심으로 컴퓨터까지 그리고 다시 사용자에게로 적절히 순환하는 구조를 가지면서 자연스럽게 계층 간 연결되는 구조를 가지게 됨.**

![](https://velog.velcdn.com/images/teo/post/cf4a3b73-785e-4549-9f4f-ab403ab1e950/image.png)

중요한 것은 각 계층만이 아니라 흘러가는 프로세스 역시 하나의 계층이라는 것. 가령, 이벤트에서 상태 변경으로 이어지는 구간은 EventHandler의 계층이고, 상태가 화면으로 변하는 것은 JSX와 같은 계층으로 표현할 수 있음.

"추상화된 계층간에 데이터의 흐름이 존재하고 데이터의 흐름은 순환적이며 자연스럽게 연결되는 구조를 가진다"

이제 데이터 흐름에 관한 내용과 앞에서 배운 추상화 계층을 합쳐 바라볼 것. -> 글쓴이가 최종적으로 전달하고자 하는 내용.

## 그라데이션 사고?(Gradation Thinking)

(그라데이션 사고라는 개념은 그냥 글쓴이가 정의내린 것)

### 그라데이션 지도 - 코드의 역할과 추상화 수준

**추상화의 방향은 데이터(저수준)에서 요구사항(고수준)이라고 하는 단방향적인 흐름을 가지고 데이터의 흐름은 순환적인 흐름을 가짐.**

추상화의 수준과 데이터의 흐름에 따른 역할에 따라 코드가 어디에 있어야 하는지 결정이 되고 이미 만들어진 프레임워크나 라이브러리들은 이러한 수준과 역할에 따라 배치가 됨.

**저수준으로 프로그래밍을 하지 않고 고수준의 프로그래밍을 하기 위해서는 저수준의 영역을 차지하고 있는 계층을 이해하고 고수준의 사고를 기반으로 프로그래밍을 할 수 있어야 함.** -> 그렇기에 **내가 알고 있는 것들, 혹은 내가 원하는 것들을 구현하는 과정에서 필요한 것들이 어떠한 흐름 계층에서 어느정도의 추상화 수준을 가지고 있는지 이해가 필요.**

![](https://velog.velcdn.com/images/teo/post/c1e9143c-3347-4742-8380-fefb3421a2b4/image.png)

가령 비슷한 역할과 데이터 흐름에 존재하는 axios랑 React-Query는 어떻게 다른 것인지 해당 라이브러리가 어떤 수준에 있는 것인지 fetch 하고는 어떻게 다른지를 이러한 지도가 머리속에 있다면 훨씬 더 이해를 하기 쉬울 것이며, 나중에 새로운 것이 나왔을 때에도 이 것이 어느구간에 속해 있는 것인지를 안다면 훨씬 더 적용을 하기에 수월할 것

그리고 **이미 만들어진 프레임워크나 라이브러리가 아닌 비어있는 구간은 실제 내가 만들고자 하는 요구사항을 구현하기 위해서 내 코드로 채워야 할 곳이며 이때 어떤 계층에 어느정도의 수준으로 채워야할지를 머리속에 그려놓는 것이 중요**

기존 생태계를 이해하는 것이 아니라 실제로 내가 코드를 잘 작성하고 잘 조립하기 위해서는 이제 어떻게 해야 할까?

### 요구사항에서 코드까지 가는 그라데이션 사고!

"요구사항에서 코드로 이어지는 과정을 **그라데이션처럼 서서히 변화하는 과정으로 생각해봅니다.**" -> 요구사항을 계층과 흐름으로 쪼개어 생각하자.

앞서 살펴본 데이터 흐름 계층과 추상화 수준으로 나눠진 구간에서 비어 있는 곳들을 요구사항에 따라 채우는 것이 내 코드의 역할. 그렇다면 내 코드가 커지고 복잡해지기 전에 미리 적절히 구간별로 쪼개둔 형태로 생각을 해보는 건 어떨까? => **요구사항을 미리 적절히 계층과 흐름으로 쪼개어 생각해보는 것은 어떨까?**

예를 들어 "테트리스의 블록 회전하기"라는 요구사항을 다시 한 번 살펴보자. 사용자로부터 키 입력 이벤트가 발생하면, 이 이벤트는 블록을 회전하는 비즈니스 로직을 거쳐 데이터를 처리하고, 그 결과로 상태가 변경되며, 변경된 상태는 화면에 렌더링됨. 이런 과정을 세부적으로 나누어 각각의 요구사항을 구체적으로 만들 수 있게 됨.

![](https://velog.velcdn.com/images/teo/post/8e0adc0f-fcc1-4d24-aaca-211bb2620be5/image.png)

그라데이션 사고법이라고 하는 키워드는 두 가지의 의미를 가지고 있음.

1. 코드가 데이터 흐름과 추상화 수준, 즉 계층을 따라 어떤 역할을 하는지를 이해하는 것.
2. 요구사항이 코드로 변환되는 과정을 단계적으로 바라보며, 각 단계를 세부적으로 나누고 채워 나가는 것.

이러한 관점을 통해 **자연어로 표현되는 요구사항을 미리 만들어진 구조화된 틀로 나눠져서 복잡한 문제를 간단하고 작은 문제들로 분리하면서 동시에 자연스러운 연결을 생각하도록 만들어주는 것.**

이 또한 의식적인 연습이 필요. 말로 하는 요구사항을 글로 적어보면서 이러한 틀에 맞는 표현으로 바꾸어보고 적어보고 그 표현과 비슷한 형태로 코드로 만들어보는 연습을 하는 것이 중요

## 코드 밖 그라이데이션 사고

추상적인 요구사항이 좋은 코드가 되기 위해서는 적절한 틀에 맞춰서 잘라서 생각을 해야하는 것처럼 **요구사항이 개발의 영역에 포함되기 전에도 복잡한 어플리케이션의 요구사항들을 적절한 틀안에서 잘라서 표현하는 것이 필요**

글쓴이의 다른 글에 적혀져 있는 내용.

![](https://velog.velcdn.com/images/teo/post/213265f8-904f-4d91-8b38-575e92180ce5/image.png)

## 끝으로...정리.

요구사항을 데이터의 관점으로 바라보면 구현이 된다.

그리고 구현된 코드를 적절한 수준으로 쪼개어 좋은 이름을 붙이면 복잡한 내용은 숨기면서 더 사람의 언어에 가까운 간결하고 가독성이 좋은 코드를 만들어 낼 수 있다.

이러한 적절한 수준의 추상화가 쌓이면 변하지 않는 좋은 코드를 만들 수 있고 이는 추상화 계층이 되어 준다. 추상화 계층을 통해서 우리는 훨씬 더 고수준의 사고와 관점으로 개발을 할 수 있게 된다.

고수준의 프로그래밍이란 이러한 계층간의 데이터 흐름으로 표현되는 것을 의미하며 데이터의 흐름은 사용자를 중심으로 순환하는 구조를 가진다.

이러한 데이터의 흐름과 추상화된 수준이라는 두가지의 개념으로 코드의 역할과 위치가 결정이 주어지게 되며 적절한 위치와 자연스러운 연결이 스파게티 코드가 아닌 좋은 구조를 가진 좋은 코드를 만들어낸다.

이러한 요구사항을 적절하게 쪼개어 좋은 구조에 맞게 표현을 하는 사고를 익히게 된다면 복잡한 개발을 단순화하고 구조화 하면서도 항상 좋은 코드를 유지할 수 있도록 만들어 준다. = 그라데이션 사고법.

## 개발은 이해가 아니라 깨달음.

아는 것으로 그치는 게 아니라, 이 모든 것들을 의식적으로 직접 실전에 적용해보라는 뜻.
