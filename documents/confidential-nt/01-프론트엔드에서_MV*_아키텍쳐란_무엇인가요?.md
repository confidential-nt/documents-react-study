[원문](https://velog.io/@teo/프론트엔드에서-MV-아키텍쳐란-무엇인가요)

## 프론트엔드에서 MVC 아키텍쳐란 무엇인가요?

### 아키텍쳐란?

- 아키텍쳐를 옷장에 비유. 규칙 없이 옷장에 옷을 정리하면 나중에 어떤 옷이 어디에 있는지 찾기도 힘듦. 그런데 규칙을 정해두면 금방 찾을 수 있음. 그러한 규칙이 '패턴'화 되면서, 나중에는 이 패턴에 맞는 목정성을 가진 옷장이 등장하게 됨. 그렇게 되면 규칙에 대해 세부적으로 의식하지 않아도 쉽게 옷을 정리할 수 있음.

- 이러한 규칙을 잡아가면서 하나의 패턴이 만들어지고, 이 패턴을 모두가 알 수 있도록 그 구조를 명시하는 것이 아키텍쳐라고 할 수 있음.

- 다만, 비유는 어디까지나 비유일뿐. 실제 아키텍쳐는 '분류'뿐 아니라, 각 모듈듈이 상호작용하는데 필요한 '인터페이스'를 가지고 있음.

'분류'와 '인터페이스'에 유념할 것.

---

### 웹 프론트엔드의 아키텍쳐 이야기

#### MVC 아키텍쳐

- Model은 DB로 간주하고, View는 html + css + js, Controller는 어떤 요청이 들어왔을 때 그 요청에 맞는 View를 보여주는. 이정도의 개념으로 해석됨

  - 참고: Model이라는 용어 자체의 밤위는 그 맥략에 따라 해석이 좀 달라질 수 있음. javascript의 Object일수도 있고, 서버의 API로 받는 데이터일수도 있으며, DB일수도 있음.
  - 참고: MVC 아키텍쳐에 대해서 말이 나올때는 웹 프론트엔드에 대한 개념 자체도 없었음.

#### jQuery 시절의 MVC 아키첵쳐

- 상호작용을 통합된 방식으로 조작할 수 있게 해주는 구세주, 제이쿼리가 나타나고, 이때쯤 비동기로 데이터를 서버로부터 받을 수 있는 AJAX도 나타남.

- 이로 인하여, 더 이상 서버에서 View를 가공할 필요가 없어졌고 이 역할은 프엔으로 넘어오게 됨.

- 그리고 '프엔'에서 MVC의 개념은 바뀌게 됨.

  - Model: AJAX로 받아온 데이터

  - View: HTML + CSS

  - Controller: jQuery

#### MVVM(Model - View - ViewModel) 아키텍쳐

- 그런데 이런식으로 개발하다보니까 불편함. -> 선언적 방법 없을까? -> 앵귤러의 탄생
- 개발자는 화면에 그려져야할 데이터만 만들어서 프레임워크에 전달해주면 프레임워크가 알아서 그려주게 됨.(템플릿)
- Model이 변하면 View를 수정하고 View에서 이벤트를 받아서 Model를 변경한다는 Controller의 역할은 그대로 인데 이를 구현하는 방식이 jQuery와 같은 DOM 조작에서 선언적인 방법으로 변경됨.
- 이를 View를 그리는 Model만 다루게 되었다고 해서 ViewModel로 명명. -> Model과 View의 관점을 분리하려 하지 않고 하나의 템플릿으로 관리하려는 움직임

  - 참고: 이후에 나오는 다른 현대적인 라이브러리, 혹은 프레임워크들(React, Vue, Angular2, Svelte)도 큰 줄기에서는 MVVM의 형태를 띈 부분이 있음

#### 컴포넌트 & Container - Presenter 패턴

- 웹 서비스가 발전하게 되고 복잡해지자, 화면을 큰 단위가 아닌, 재사용가능하고 조립 가능한 컴포넌트 단위로 만들자는 움직임이 생겨남
- 이 과정에서, 재사용성을 많이 강조하다보니, 비즈니스 로직을 가진 최상단 컴포넌트 - 그리고 오직 UI 관한 것만 담고 있는 컴포넌트로 분리하는 패턴이 유행하게됨.
- 이것을 바로 Container - Presenter 패턴이라고 하며, 비즈니스 로직을 갖고 있는 것을 Container , 비즈니스 로직을 갖고 있지 않고 그 아래에 props를 통해 데이터를 뿌려주고 그걸 표시하는 컴포넌트를 Presenter라고 함.

  ![](https://velog.velcdn.com/images%2Fteo%2Fpost%2F766126fa-f814-44bb-a72c-212a52be1c20%2Fimage.png)

- 그러나 문제점: Props Drilling. 컴포넌트 구조가 복잡해짐에 따라 하위에 특정 값을 전달하기 위해서는 중간 레벨에 있는 컴포넌트들은 전부 그 props를 가지고 있어야 하는 문제가 발생. 상단에 있는 데이터를 하단에 있는 props로 보내기 위해서 중간 계층에 있는 props를 하나씩 추가하는 문제를 Props Drilling Problem이라고 함.

#### Flux 패턴과 Redux

- 기존의 MVC에서 벗어나 단향향 흐름을 만들자! 단방향 아키텍쳐를 만들자!
- 여러 컴포넌트가 같은 상태를 공유할 때, 어떻게 이 상태를 변경할지도 문제고 이 상태가 필요한 컴포넌트에게 상태를 전달하는 것도 문제다!
- 기존의 컴포넌트를 지향하는 MVC가 아니라 View를 하나의 범주로 두고 View에서 Action을 호출하면 Dispatcher를 통해 Store라는 공간에 Data가 보관이 되고 다시 뷰로 전달되는 흐름을 만들자! -> Flux 개념 탄싱.
- 비즈니스 layer - View Layer 둘 사이의 관계는 Action과 Reducer라는 인터페이스로 분리하고, Controller는 이제 양방향이 아니라 단반향으로 Cycle을 이루도록 설계한다.
- Flux는 개념. 구현체가 아님. Redux가 Flux 개념의 구현체.
- FLUX 패턴은 View를 각각의 MVC 컴포넌트 관점으로 보는 것이 아니라 **하나의 큰 View로 이해**하고 View에서는 Dispatch를 통해서 Action을 전달하면 Action은 Reducer를 통해서 Data가 Store에 보관이 되고 Store에 들어있는 데이터는 다시 View로 연결이 되는 방식을 지향
- 기존의 컴포넌트 단위의 MVC개념에서 완전히 비지니스 로직과 View를 분리하면서 이 분리된 개념을 **상태관리(State Management)**라고 부르게 됨
- 그리고 많은 상태관리 라이브러리들이 만들어지기 시작한다.
- 그러나 리덕스의 문제점? 너무 복잡하고 장황하며 학습곡선이 높다. 이를 해결하기 위한 다양한 시도가 있어옴 : Observer - Observabale Pattern, MVI 패턴 ...

---

### 현대 웹 프론트엔드의 아키텍쳐 방향성들

#### Context Hook

- Props Drilling이 그렇게 문제라면, 그냥 복잡하게 외부 의존성 쓰지 말고, 리액트에서 제공하는 Context API 쓰자라는 움직임. 즉, 프레임워크(라이브러리)에서 제공하는 거 그냥 가져다쓰자..

#### Atomic 패턴 - Recoil, Svelte

- 거대한 View영역과 Store영역을 나누어 이분법으로 생각하자는 의견에는 동의하나 Action ~ Dispatch ~ Reducer와 같은 복잡한 구조를 가져야 하는가에 대한 방법에 대해서는 회의적인 시각으로 만들어진 방법들. Redux보다 훨씬 간편.

#### React Query - MVC의 개념 확대

- React-Query는 이러한 **상태관리에 편향되어 있던 시각에서 벗어나 고전적인 AJAX의 데이터를 Model**로 간주합니다. 대부분의 프론트엔드 개발은 서버 데이터를 CRUD하고 시각으로 그리는 것에 중점이 되어 있는데 FLUX나 Atomic은 너무 복잡한 방법이라는 것.
- 서버와의 fetch 영역을 Model로 간주
- View는 React
- Controller는 query와 mutation이라는 2가지의 인터페이스를 통해서 서버 데이터의 상태를 관리하고 캐싱, 동기화, refetch등을 관리해주는 역할

#### GrahphQL, firebase - Schema Based 아키텍쳐

- 미리 스키마를 정의하고 스키마를 기반으로 해서 데이터를 교환한다라는 개념
- 나머지는 리액트쿼리와 비슷

---

### 마무리

#### 최근 아키텍쳐의 방향성

- 단방향 아키텍쳐
- 선언적 프로그래밍을 통한 Controller
- 뷰와 비지니스 로직의 분리(상태관리)
- 반응형 프로그래밍(Reactive Programming) : 시간이 지남에 따라 변화하는 데이터의 변화에 '반응'한다는 것.
- 서버와의 연동을 Controller로 간주하는 움직임
