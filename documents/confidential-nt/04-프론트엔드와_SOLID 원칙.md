[원문](https://fe-developers.kakaoent.com/2023/230330-frontend-solid)

## 프론트엔드와 SOLID 원칙

### SOLID 원칙이란?

- 개발자라면 SOLID 원칙에 대하여 들어봤을 것.

- 그러나 오히려 미리 아는 것이 독이 될수도.

- 왜냐하면 SOLID 원칙에 관하여 정확히 설명한 글이 없다.

- 특히 가장 중요한 SRP에 대하여, 실무 레벨로 정확히 설명한 글이 없다.

- FE에서 SOLID 원칙을 정확히 이해하고 사용하는 것은 매우 큰 도움이 된다.

---

### 콘웨이 법칙

- SOLID는 원칙. 원칙보다 우선하는 것이 법칙. 법칙은 '진리'를 의미하는 것.

- 콘웨이 법칙은 SW 공학에서 유명한 법칙으로, SOLID의 대전제가 되기도 함.

- 그래서 콘웨이 법칙이란, "소프트웨어 구조는 해당 소프트웨어를 개발한 조직의 커뮤니케이션 구조를 닮는다" 라는 법칙.

- 이것은 곧, 소프트웨어 구조와 커뮤니케이션 구조가 다르다면, 어딘가 잘못된 구조라고 해석할 수 있음.

- 소프트웨어 구조와 커뮤니케이션 구조가 다름 -> 요구사항 변경 시 커뮤니케이션 비용 발생 + 요구사항 변경 시 코드가 유연하지 못해 이에 관한 비용 발생

- 이 법칙에 입각하여 소프트웨어 구조를 커뮤니케이션 구조와 유사하게 만들 수 있도록 하는 SOLID 원칙 중 하나가 SRP.

---

### SRP : Single Responsibility Principle

- **SRP는 SOLID의 시작과 끝.**
- 다른 원칙은 이 원칙을 위해 만족해야하는 것.
- **SOLID는 코딩 기법이 아니라 원칙이다.** **기법으로 접근하게 되면 하나의 책임 = 하나의 동작으로 인식하게 되어 단일한 동작을 가진 컴포넌트로 쪼개야한다는 오해가 발생.** 그러나 이렇게 하게 된다면..그 기준이 애매해지기도하고 과할 정도로 자잘하게 컴포넌트가 쪼개질 수 있음.
- 단일한 동작을 갖도록 코딩하는 것은 “컴포넌트” 가 아니라 순수한 함수 한정 : 이것은 아키텍쳐라기 보단 클린 코드의 영역.
- 그렇다면 정확한 SRP의 의미는? **"하나의 모듈은 오직 하나의 액터에 대해서만 책임을 져야한다."**
- 모듈 = 컴포넌트 / 액터 = 이해관계자 집단. 더 자세히 얘기하자면, **요구사항을 전달하는 책무 단위.**
- 중요한 점은 SRP의 ‘책임’이 의미하는 것을 소프트웨어 내부의 ‘동작’ 이나 ‘논리’가 아니라 **조직 간 커뮤니케이션 영역으로 봐야 한다는 점**
- 컴포넌트를 설계 할 때, 요구사항을 전달하는 책무 단위로 설계를 하면게되면, SRP 원칙을 지킬 수 있다.

#### 책무 기반 컴포넌트 설계

- SW는 요구사항에 의해 만들어짐. from 사업부서, 마케팅부서, 기획부서, 디자인부서, 개발 조직과 개발자 본인...
- 컴포넌트 설계는 이러한 요구사항을 전달하는 책무 단위로 설계 되어야.
- 각 영역의 요구사항을 명확히 파악하고 영역을 구분해 의존성 없는 독립적인 컴포넌트로 만들어 각 책무의 요구사항 변경에도 유연하게 대처할 수 있도록 설계하고 구현하는 것이 키포인트.
- 기획과 디자인 조직이 분리되어 있다면 각각의 컴포넌트로 분리되어야. 만약 디자이너가 기획도 같이 진행하는 조직이라면 UI와 비지니스가 결합된 컴포넌트로 만들어도 무방. 중요한 것은 컴포넌트와 요구사항의 변경 범위가 최대한 같도록 설계하는 것
- 카카오페이지 프론트엔드 구조에 영향을 주는 책무 예시)
  ```
  서비스 개발 그룹
  ├─ 기획
  ├─ 디자인
  ├─ 개발
  │  ├─ 메인API
  │  ├─ 섹션API
  ```

#### 기획(UX) 책무 -> 즉, 흐름을 어떻게 가지고 갈 것이냐...

- 기획에 들어가는 내용: API 에서 전달된 데이터를 어떤 디자인과 연결할지 정의하고 컴포넌트의 제약조건과 예외사항을 정의
- 개발조직이 아님에도 무의식적으로 컴포넌트 별로 정의를 하고 있더라.
- 자세한 예시는 원문 참고
- 이들이 만든 산출물을 토대로 컴포넌트 이름을 짓고 컴포넌트를 만들어나가면 됨 -> **커뮤니케이션 구조와 소프트웨어 구조가 동일해지는 효과. 커뮤니케이션 미스가 줄어듦.**
- **기획에 대한 단일한 책무를 갖는 컴포넌트가 만들어지게 되는 효과.**
- 기획서에 적힌 컴포넌트 이름이 애매모호하다면 상의해서 바꾸면 되겠지...
- 기획서에는 제약조건 및 예외사항이 정의되어있음 -> 무엇을 테스트하면 될지를 알려줌.

#### 디자인 책무(UI)

- 디자인 시스템 사용하는 그룹이라면.. -> UI를 컴포넌트화 시켜서 디자인하고 있더라.
- 이 디자인 시스템대로 UI 컴포넌트를 또 만들면 됨.
- 디자인 시스템 쓰지 않으면 많이 복잡함. 조직의 구조와 SW 구조가 다르기 때문에 커뮤니케이션 비용 많이 들고, 뭐 하나 변경하는데도 겁나 복잡해짐.
- 자세한 이야기는 원문 참고.
- 디자인 시스템 사용하면 응집도 높은 UI 컴포넌트들이 도출됨.
- 도출된 컴포넌트를 개발에서 그대로 사용하기 위해 **아토믹 디자인**을 차용했다고..
- 아토믹 디자인은 **UI영역의 SRP**를 만족할 수 있게 해주는 아주 고마운 개념이라고..

### OCP : Open-Closed Principle

- 요구사항이 변경될 때 **기존 코드를 변경하는 것이 아니라 새로운 코드를 추가하는 방향을 추구하는 원칙**
- 자세한 예시는 원문 참고.
- 최근 많은 서비스에서 표준처럼 자리잡은 섹션 방식의 UI를 예로 들음.
- 이 섹션은 서비스 운영 도중 추가/변경/삭제되는 것이 매우 명확 -> OCP를 도입하기 좋은 케이스
- 변경에 대응하기 좋게 다형성 이용
- 그러나 섹션 구조에서는 API로 내려주는 데이터가 나중에 얼마든지 바뀔 수 있음 -> 미리 대비해야.
- 섹션 구조의 OCP를 해결하기 위한 패턴이 존재. 카카오 페이지는 애플에서 제안하는 Compositional Layout 패턴을 사용한다고..
- 섹션을 일반화 해보면 Section, Group, Item 형태로 대부분의 모습을 표현할 수 있다는 컨셉

### LSP : Liskov Substitution Principle

- 보통 클래스의 상속의 관점에서 설명하지만 좀 더 광의적인 의미로 사용할수도 있음. 아키텍쳐적인 관점에서는.
- “상속(is-a)으로 이어진 관계에서 예상 못할 행동을 하지 말라”.가 골자.
  - is-a ? 사과는 과일이다
- SOLID 원칙 중 ‘장애상황’, ‘버그’와 가장 밀접하게 관련된 부분이 LSP 원칙
- 인터페이스나 상위 정의된 부분과 실제 구현된 부분이 ‘예상’과 다르다면 잘못 사용하게 될 가능성이 매우 높아짐.
- **상속 관계로 간주할 수 있는, 당연하게 여겨지는 명제가 예상과 다르게 펼쳐지는 것. 이것이 LSP 위반**
  - ex) 컴포넌트 이름과(컴포넌트의 책임) 관계없는 기능을 어떤 유혹에 의해 끼워넣는 경우...
  - ex) Label 이라 해놓고 체크 박스 기능 요구
  - ex) API 응답으로 주기로 약속한 모델을 화면마다 다르게 내려줌
  - ex) GET method 의 REST API로 정의했는데 실제 동작에선 DB 상태를 변경
- 위반하게되면 나중에 이슈 발생시 원인을 찾기도 힘들어짐.
- 팁: LSP를 일종의 레이더로 사용하자.
  - ‘정의된 것과 달라 찝찝하지만 일정 상 어쩔 수 없으니 이대로 가자’
  - 정말 그대로 가게되면 나중에 벼락맞음.
  - 저런 찝찝함이 느껴지는 이유는 애초에 구조가 잘못돼서 그런 경우일때가 있음 -> 개선해나가다보면 코드가 좋아질 것.

### ISP, DIP : Interface Segregation Principle, Dependency Inversion Principle

- SRP를 잘 실천했다면 컴포넌트를 불필요한 Props(속성) 없는 독립된 컴포넌트로 구성할 수 있을 것.
- 하지만 컴포넌트만 있으면 페이지 구성 못함. 페이지를 만들려면 컴포넌트를 조합해야.
- ISP와 DIP는 컴포넌트를 조합할 때 도움주는 원칙.
- 자세한 예시는 원문 참조.
- **컴포넌트에서 관심사에 맞지 않는 부분에 대한 의존성을 역전시켜 느슨하게 만들어주는 원칙** => DIP 원칙.
  - 리액트에서는 **children**을 사용할 수 있음.
  - children은 리액트의 꽃. 의존성을 느슨하게 관리함으로써 조립(Composition)이 가능하도록 만들어줌.
- 의존성이 역전되면 원하는 관심사만 테스트하기 쉬워짐.
- ISP는 Compound Pattern을 통해 개선해볼 수 있음 => 하나의 컴포넌트를 통해 모두 컨트롤하고 있던 부분들을 Compound Pattern을 통해 나눠볼 수 있음 => 컴포넌트가 꼭 필요한 인터페이스만 받도록 변경됨.
- 각자의 책임에 따라 적절하게 의존성 분리 + 개선 필요.

### 마무리

- **아키텍처를 구축해갈 때 SOLID 원칙에 기반한 사고 체계를 가질 수 있다**
  - 커뮤니케이션 구조를 기반으로 컴포넌트의 네이밍부터 시작해 각각에 맞는 책임, 책무를 정의하고(SRP) 변경하는 요구사항을 최소한의 코드 (추가를 통한) 변경을 통해 유연하게 대응하고(OCP), is-a를 의도했다면 그 의도에 맞게 구현되도록 힘쓰고(LSP), 컴포넌트에 꼭 필요한 인터페이스만 의존할 수 있도록 구성하고(ISP), 필요하다면 의존성을 역전시켜 독립된 컴포넌트로 만들 수 있도록(DIP) 끊임없이 생각하고 개선해가는 경험과 태도가 중요
- 원칙은 가치(Value)와 실천(Practice)사이를 이어주는 다리
- 각자가 처한 상황 속에서 이루어내야 할-영리 회사라면 안정적인 운영과 비지니스 속도에 맞출 수 있는 개발속도 라는 가치를 실천해갈 수 있도록 도와주는 다리 역할을 해줄 수 있는 것이 SOLID 원칙
- 한 가지 주의해야 할 점은 **목표로 삼아야 하는 것은 SOLID 원칙이 아니라 ‘가치’가 되어야 한다는 점**입니다. 이 원칙들을 통해 이루어낼 수 있는 가치를 먼저 찾고, 커뮤니케이션 구조를 면밀히 관찰하며, 베이비 스텝으로 천천히 적용해나가자.
